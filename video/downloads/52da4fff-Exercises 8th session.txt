~Exercises: 8th session
~2020-11-16T18:19:50.432+01:00
~https://tube.switch.ch/videos/52da4fff
~CS-451 Distributed algorithms
[0.0:15.0] And then we can, yeah. So, okay, hello everyone. Today we are going to present solutions for the exercises we gave you last week.
[15.0:24.0] So the exercises we gave you last week were concerned with group membership and the views in community.
[24.0:38.0] Okay, so let me just check again, is everything fine? No problems? Okay. Okay, so let's start.
[38.0:51.0] So in the first exercise we asked you to show that perfect failure detector is indeed the weakest failure detector
[51.0:56.0] that can be used to implement and to solve the problem of the group members.
[56.0:71.0] So we gave you a small hint here that in order to show that this indeed is the case, what you should do is use group members in order to implement the perfect failure detector.
[71.0:93.0] Let me just give you a brief brief intuition why this is, why if you showed that you can implement the perfect failure detector using the group membership, you showed that the perfect failure detector is indeed the weakest failure detector that can be used to implement the group and to solve the group members should problem.
[93.0:115.0] So, suppose that this is not the case, okay. So suppose that you have some failure detector P prime that is weaker than the perfect failure detector and that you can use P prime this weaker failure detector to implement the group and to solve the group members should problem.
[115.0:141.0] But then if we show that you can use group members should to solve the perfect failure detector, you effectively has used a P prime failure detector that is weaker than the perfect failure detector in order to implement the perfect failure detector, which is a contradiction with the fact that P prime is indeed weaker than the perfect failure detector.
[141.0:156.0] So here we also asked you to show that in the opposite direction just to pretty much show that from the computation perspective, perfect failure detector in group members should have equivalent equivalent problems.
[156.0:171.0] Okay, just some small note here, I will be tracking the, like during the presentation, I will track the chat so I will not potentially answer right away.
[171.0:178.0] Okay, so in order to show pretty much what you have here, what I just explained.
[178.0:193.0] So in order to firstly show that if you have a perfect failure detector, you can have group members should, you can just look at the presentation, you can just look at the presentation and the algorithm from the class.
[193.0:205.0] Right, right. So you have a perfect failure detector and the perfect failure detector satisfies the song completeness and accuracy property just a second because someone is not muted.
[205.0:233.0] Okay, so yeah, we can continue sorry for this and you can use the uniform consensus and then if you take a look at the algorithm from the class, you pretty much show that if you have a perfect failure detector, you can have a group members and I'm not going to go into this.
[233.0:243.0] But the more interesting direction is the opposite. So suppose now that you have a group members with algorithm and you want to solve a perfect failure detector.
[243.0:254.0] How do we do that? Well, whenever a new view is installed, all processes that are freshly removed from the view can be safely detected.
[254.0:262.0] Why is this indeed the case? Well, this is indeed the case because of the accuracy property of the group members.
[262.0:287.0] That says if a process installs the view such that some process P is not in that view, then P has crashed. So here if you have a process that installs a view, you can take a look at the processes that are not in the current view, but were present in the previous few and you can safely conclude that they they they have crashed.
[287.0:298.0] Okay. And you can have so this is how we how we how we solve accuracy and this also gives you completeness.
[298.0:310.0] This approach why because of the completeness property of the group membership that says that if a process P crashes, then there will be eventually a view such that P is not in that view.
[310.0:324.0] So again, eventually it will happen that if some process has crashed, it will happen that there will be a view such as this process is not the member is not a part of that view and thus that process will then be detected.
[324.0:331.0] So I guess everything should be clear here. So let me check whether there are any questions. Yes.
[331.0:342.0] Okay. Okay. So if you have any questions for this, I'll give you for this exercise. I'll give you a few seconds.
[342.0:349.0] As an aside, I'm online. If you want to can I can read the questions from the chat. So you can give me.
[349.0:352.0] Yeah, yeah, that would be awesome. Thanks.
[352.0:362.0] Okay. So yeah, then I guess we are back to the original strategy that was violated because of me last time. Sorry for that. But today.
[362.0:372.0] Yes, today we are back to the original structure of material reading the questions and me presenting presenting the sides and the answer.
[372.0:377.0] And we are going against which next time. Okay. Let's let's something.
[377.0:394.0] So now we have the second exercise. So if you remember the group membership and the viewers think from the communication abstractions from the class, they are they were only concerned with processing processes crash. Right.
[394.0:406.0] So a process that really install a view a new view only once when some change in the membership of the system has happened.
[406.0:420.0] This change is all can only be due to process is crash. But what is also a natural question now is okay, but maybe you want to have a system where process can also join and potentially also leave.
[420.0:425.0] So can we devise something similar to group membership?
[425.0:439.0] Construction and use in terms of communication instruction, but where membership will change not only because some process is may crash, but also because some process is may join the system may want to join the system.
[439.0:452.0] So that is what we try to tackle here. So not only that the membership will change because of some process is crashing, but also because some processes want to join the system.
[452.0:466.0] So the first question we ask you is that if you take a look at the properties of the group membership and the view of using in community, using in communication that you are hopefully familiar with now.
[466.0:472.0] Why these properties do not really work if we assume that processes can join.
[472.0:485.0] Okay, so if you remember the properties of using in communication, so we have some properties of the reliable broadcast validity and creation, no duplication and agreement.
[485.0:491.0] We have properties of group membership that are local monotonicity agreement again completeness and accuracy.
[491.0:504.0] And then we have this additional view inclusion property that says that if a process delivers a nice jam from process P in some view, we then and was broadcast by P in that same view.
[504.0:520.0] Okay, so what we are going to do now is we are going to take a look at the properties of group membership and then try to figure out why these properties do not really work if we assume that processes can join the system and not only crash.
[520.0:530.0] Okay, so the first property of local monotonicity says that pretty much you have two views.
[530.0:535.0] We and they prime such that we received we prime.
[535.0:542.0] Then and prime must be subset of M.
[542.0:557.0] So this simply means that that must mean that we installed and prime we installed the view be prime because some of the process is crashed, which then trivial means that the membership of the process of the system has decreased.
[557.0:572.0] So again, this is not really not really does not really work for joins because some process may just want to join the system and then you don't have you don't have this property.
[572.0:579.0] Because let's say that you have a free processes in the initially and then process number four wants to join.
[579.0:589.0] And for example, process number three crashes, then in the following view, you will have that the members of the new view are processes one, two and four.
[589.0:599.0] So we need to be able to somehow reason about this relation between the initial view, the view be in my scenario with processes one, two and three.
[599.0:612.0] And the new view with processes one, two and four that represents the let's say the new membership of the system. So we need to somehow take into account that processes will not only crash, but also join uniform agreement.
[612.0:626.0] This one is okay. We don't have to do anything there. It simply says that processes that install a view with some sequence number will install the same view and this looks like looks like, you know, a natural property.
[626.0:635.0] Then again, we have completeness that says that if process be crashes, then eventually every correct process is also view such that P is not the member of that view.
[635.0:650.0] Again, we only have the situation that it is property tries to deal only with crashes, but we should also do something with joins, right?
[650.0:662.0] But we would like to ensure that if correct process asks to join the system that then you will eventually there will be a view where such that that process isn't the member of the system, right?
[662.0:672.0] Because otherwise it is as if we do not really solve this problem of processing processes being being allowed to join the system.
[672.0:680.0] Lastly, we have accuracy that says that if some process installs a view without some some process, then that process has crashed.
[680.0:701.0] But this is also something that is similar to the completeness property in a sense that we also want to we also want to ensure that if there is indeed a view installed by some process that contains some process speed, for example, then we want to ensure that this process be has indeed involved.
[701.0:710.0] So if indeed expressed it is real to join the system or of course was the member of the system initially.
[710.0:724.0] So what we figure out here is that properties 1, 3 and 4, so properties local monotonicity, completeness and accuracy are not really suitable and do not really work with processing being allowed to join the system.
[724.0:742.0] So what we now ask you is to follow, okay, but let's now adapt, let's modify the specification of the view of the viewers information communication such that we allow process to join and such that the new specification, you know, makes sense.
[742.0:752.0] Okay, so if we are talking about local monotonicity, we figure out that there might be two possible ways of dealing with this problem.
[752.0:768.0] So the first local monotonicity property that we are going to introduce simply says that if a process installs a view V and then installs a view of v prime, then the memberships that are associated with V and v prime are not the same.
[768.0:782.0] Okay, so here if you take a look and an end which represents a membership of V and then represents a membership of V prime, sorry, we here we should write V prime.
[782.0:789.0] I will do that for the before I upload this site, then M should not be equal to M.
[789.0:808.0] And this makes sense, right, because we want only to for our system to change in its membership through this through installations of new view, new views only if there is indeed a change of the reason, the change that is observed by processes in the system.
[808.0:819.0] Let's see what the consequences of this first monotonicity property. So consecutive views of course must have different set of process, this is what I just explained.
[819.0:824.0] But different views can have the same set of process, right.
[824.0:841.0] So here we give you a scenario where you have that some process here wants to join the system and it does so because there is some sequence number i plus one, there is a this guy joins the system, there is a view that includes this guy.
[841.0:849.0] But what happens is now that this guy queue crashes and then you are back to the original membership.
[849.0:854.0] So this is something that is extremely interesting.
[854.0:865.0] The third consequence is the proper processes can be excluded from a view which simply means that they can join crash, recover, join again and stuff like that.
[865.0:881.0] And as you will see this is somehow somehow could be a bit a bit problematic, but that is that is where the second proposal for the local monotonicity property that we want to give can.
[881.0:903.0] So if you have if we take a look at the second property, second local monotonicity property says that if RSS installs views a V here and we prime here subject yacht is bigger than I, which simply means that this view is installed after this view.
[903.0:919.0] And you have some process that is here and not here then for all views installed after this view we prime with single somewhere yacht queue will not be member of that view.
[919.0:922.0] Okay, so I hope this is clear to everyone.
[922.0:942.0] But now we have this consequence that says that okay, but now once we exclude the process from a view it can ever come back. Right. So once a process has crashed this process can never can never resurrect himself itself and that's it.
[942.0:967.0] In practice, I would say that also in the lecture literature with you know when you have some papers that deal with problems similar to this one, this is this is an assumption that pretty much every single every single algorithm has that simply says that if a process joins the system or leaves the system or crashes, it can never it can never get back with the same idea.
[967.0:980.0] Of course, in fact, this is easy for for for asked to overcome because we can just we can just you know allow that process to adopt a new identifier and then everything is fine.
[980.0:1000.0] But trust me in it makes when defining properties of this of this of similar abstractions and especially when when dealing with the you know with the implementation of it, this assumption that the process can only join leave or crash once.
[1000.0:1025.0] You know makes your life really way way easier. Okay. So just to summarize, we have for in order to deal with local monotonicity property that doesn't work if we just take the original local monotonicity property from the from the from the group membership using synchronous communication of instructions that you have seen on and for sheets fast.
[1025.0:1036.0] So what we do is we provide two different proposals that can be used to to let's say fix this local monotonicity property from the class. Okay.
[1036.0:1048.0] Let's continue. Let's now deal with completeness property. So again, we figured out the completeness property from the original group membership or abuse synchronous communication of traction does not really work right.
[1048.0:1072.0] But what we do here is the following. So we have we have divided this completeness property into two sub properties. So the first property says the following if a process be crashes, then there exists a view such as the total correct processes install a view without that process that crash process be being a member of that.
[1072.0:1083.0] Which is something extremely similar and I would say the same as the original property of the of the group membership or using synchronous communication.
[1083.0:1096.0] However, we also need to deal with joins right. So then we say the following if a correct process queue request to join and then exists a view such as every correct process installs that view.
[1096.0:1111.0] And such that process queue this is sorry, this is a mistake here process queue belongs to that view. Okay. So this property simply says if you want to if you want to join the system.
[1111.0:1140.0] If you and you are correct, eventually you will indeed be able to join the system. Okay. So this in a sense, something minimal that we should that we must let's say be able to provide because otherwise if you're a correct guy and you do everything according to to to what we specify and you still do not join and you still do not join the system then our protocol our specification doesn't make much sense.
[1140.0:1168.0] Again, we have the second complete and property that is exactly the same as the first one. It's just it is just so what we did here is that if you adopt the first formulation of the local monotonicity property, this is how to get the the complete and property that you know resonates with the with the first local monotonicity property.
[1168.0:1181.0] But here we do we do the same for the for the second local monotonicity property, but process properties C1 and C2 are exactly the same. Okay.
[1181.0:1187.0] Now we again need to deal with accuracy property.
[1187.0:1213.0] And we say the following which is exactly the same as the as the original property property from the from the class from the sheet class is just slightly slightly formulated in a slightly different manner, but it simply says that if you have a process that is not a member of some view that is installed, then that process has crashed.
[1213.0:1230.0] Okay. Yes. Sorry. So we have a question. It says in C1 B, the end of the sentence shouldn't it be shouldn't there be such that Q is in M? Yes. Yes. I have said that this is a mistake and that it should be Q.
[1230.0:1244.0] Not. No. Yeah. You're not big. Yeah. That's a good observation. Thank you for I will fix this before before I upload the decides. Okay. So accuracy property that's fine.
[1244.0:1261.0] But we also need to somehow deal with joints, right. So you can consider this join integrity property to be just the second part of the accuracy property something similar what we did here.
[1261.0:1270.0] And this joint integrity says the following. If some process installs a view such that some process Q is in that view.
[1270.0:1296.0] Okay. Thank you. Either previous request that you join or Q were were Q was the member of the system initial. That simply means that if there is a process that is a member of some installed view, then that process must have must have invoked the joint operation or of course was a member of the system initial.
[1296.0:1312.0] So I hope this is because what we want to avoid is that we want to avoid adding processes to the system that really do not want to be part of the system. Okay. I hope this is this is clear to you.
[1312.0:1321.0] And lastly, we have this what we want to what what is very interesting to us is this agreement property of the reliable broadcast.
[1321.0:1331.0] So agreement property simply says that if a correct guy correct guy delivers and then every correct guy delivers that.
[1331.0:1341.0] But does this property really make sense in in our in our specification world that is debatable.
[1341.0:1357.0] So that is why here we provide two different again to different form to different let's say types of the of the agreement property that you could indeed use in order to achieve to achieve an abstraction that makes sense.
[1357.0:1371.0] So the first property the property a one is exactly the same as the original agreement property from the reliable broadcast. If a message I was delivered by some correct process, then I am eventually delivered by a correct process.
[1371.0:1381.0] But what is here very important well here it is very important and once the process joins the system a correct process joins the system.
[1381.0:1395.0] It must catch up with all the previously delivered messages. So suppose that you have a message delivered by a correct process at time t equal t equals zero for example.
[1395.0:1402.0] So process just the system just has just started executing and you have a correct guy delivering the message.
[1402.0:1425.0] And then at time t equals 100 you have that some correct process p joins the system well if we if we decide to keep the a one property that also means that process p must deliver the message that was delivered by this process at time t equals zero.
[1425.0:1442.0] Okay, so this is why we also give another slightly modified property that says that if a message is delivered by some correct process in some view V, then M is eventually delivered by your correct process that are members of this.
[1442.0:1471.0] So now you do not have a broadcast. So you don't think anymore as a as a broadcast with to. Okay, so with the agreement property a one you can look at the broadcast primitive as a global let's say global broadcast primitive why because no matter where you join when you joined the system or no matter where you crash or whatever.
[1471.0:1482.0] So of course you cannot crash your a correct guy so no matter when you join the system all messages that are delivered by correct processes will also be delivered by you.
[1482.0:1496.0] But if you adopt the property a two now you have that a broadcast primitive is let's say specific to a view so only if there is the correct processing that you.
[1496.0:1509.0] That delivers a message and you are member of that you and of course you are also correct only then you will deliver a message also so in this way what can potentially happen is that.
[1509.0:1515.0] The process that joins the system does not really need to catch up with all previously delivered messages.
[1515.0:1533.0] Okay. And lastly what we have is of course this here inclusion property and we just keep it in unchanged this is this is something that should be clear to everyone.
[1533.0:1552.0] We don't need to change it in any way because it really doesn't have to do anything with the original algorithm and doesn't need to have anything with process crash it's simply states that if a process delivers a message and some view then that message was indeed broadcast in that view.
[1552.0:1575.0] Okay. Let's see we ask you to now implement this but we want you to take a look at the consensus based algorithm this is algorithm to from the from the from the lectures and to take care of the of the of the processes being able to join.
[1575.0:1582.0] So what we give you here are our algorithm and such that modifications are given in red.
[1582.0:1588.0] Okay.
[1588.0:1612.0] So if you take a look at the algorithm from the from the from the lectures you have this event that is event for initialization right so in this event you simply state what is the what is your current view which are the processes that are correct.
[1612.0:1629.0] You have this property you have this flag for flashing for blocked for weight you have sets of pending messages sets of delivered messages and here we introduce a set of crash messages crash process.
[1629.0:1649.0] So as you say here questions that the tracks the events from the failure detector so we have here the we have here here the the perfect failure detector so it is useful in an execution for a process attempts to join the system but then crashes.
[1649.0:1667.0] So we will use this crash property to be able to fix the membership of the new viewers such that it does not really include this process because the process fight to join the system and only then crash which simply means that is that's it.
[1667.0:1673.0] It is as if the process didn't do anything before that.
[1673.0:1700.0] We have this map we have this acknowledgement acknowledgement array or set however we want to call it we have this scenery or map if we want to be more precise and what happens here is that we trigger this trigger this few new event that simply says that this new view is now installed.
[1700.0:1704.0] This is also added here is the following.
[1704.0:1729.0] If this process execute in this code is in the initial view of the system which is defined by this by P sorry then we set this joint flag to true which simply means yeah I'm already in the system or to false which says okay I'm not in the system I should see whether I want to join or what are my big issues.
[1729.0:1758.0] Okay so now once a process wants to join wants to broadcast some message that is represented by this event broadcast it also needs to check whether the process is indeed joined has indeed joined the system so a process that has not joined the system yet is not allowed by our by our algorithm to broadcast any messages.
[1758.0:1787.0] The same happens with this deliver message with this delivery event sorry so when you deliver a message you also need to show you also need to sorry check whether the to check whether you are you have already joined the system otherwise you don't do anything you just let's say ignore this event until until the the joint flag is set to true.
[1787.0:1794.0] Okay any questions so far.
[1794.0:1816.0] Okay I guess I guess no then again once you once you once you deliver this sorry yeah so I hear there is a mistake sorry for this this should be best effort broadcast and not this.
[1816.0:1833.0] This should be an event that is that is invoked it is a callback from the best effort broadcast primitive and not from this here synchronous communication primitive with joints so sorry for this I will write this down and I'll fix this.
[1833.0:1839.0] Okay so let's continue so here.
[1839.0:1856.0] This is the part of the code where you collect this acknowledgements by processes and deliver potentially a message again you need to check whether you joined the system otherwise you do not do anything.
[1856.0:1882.0] And if you get if you get if you get a hint from the perfect failure detector in order to apply that hint you also need to be joined and what is also important is is that not only that you remove process fee from the set of correct processes but also you include process fee in the set of crash process.
[1882.0:1906.0] And lastly we have this we have this property that is used for for setting this flashing flag to true and for blocking from being able to broadcast any more messages temporarily again what you need to do is check whether you joined the system and note.
[1906.0:1921.0] Notice here that we do not have the property that says that correct correct processes are subset or equal to them but you only have that correct process are not equal to.
[1921.0:1930.0] So this is a big difference from the from the from the previous from the original algorithm why well because we want processes to be able to check.
[1930.0:1950.0] Now if we go go go further then again once you receive this pending message you also need to be able to to you only deal with this message if you join the system okay.
[1950.0:1965.0] And this part for this part from for the initial initial initializing the new instance of the uniform consensus and proposing to it stays completely the same.
[1965.0:1986.0] Okay sorry for this and now we have this to let's say events that we completely introduce because we want to be we want to allow process to join so the first event is event is signalized that the process has indeed expressed it's real to join the system.
[1986.0:2001.0] Notice that this can only be invoked if the joint is equal to false and once this happens the process simply broadcast using the best effort broadcast is request for it to join the system.
[2001.0:2010.0] And that's it once a correct process once a process sorry delivers this message from the best effort broadcast.
[2010.0:2025.0] It simply says that the process that the members the correct processes include process P and we need to remove this crash because from the because as we explained what could what could have happened is a process P.
[2025.0:2038.0] So it's after broadcasting using the best effort broadcast is request as fresh so then in that case we should not really take P into an account.
[2038.0:2064.0] Okay and lastly we have this part of the original protocol unchanged but at the end of this in the end of the procedure that is invoked upon observing an event of consensus protocol deciding we need to inform all the processes that are members of this new view that this new view is indeed installed quite this important.
[2064.0:2092.0] So it's important to inform processes that need to join the system now that are members of the new view but were not members of the previous view to receive to receive this message and to start to start considering themselves as a participants to the system which implies says that they should set this joint flag to true.
[2092.0:2120.0] And again if processes receive this message they check whether they are indeed members of this new view and if they are they update their view of the system they say that correct processes from their perspective are the members from this view and they set this flag joint to true which is very important and they just invoke this joint OK event that simply says yeah OK I have joined the system everything is fine.
[2120.0:2126.0] OK so do you have any questions here.
[2126.0:2148.0] I'll give you a few few seconds so here just know that this should be faster for broadcast and I will deal with this after the class and yes and I'll go again to this to this pseudo code to see whether there are potentially any other problems.
[2148.0:2161.0] OK I guess there aren't any questions so I'm going to close this presentation and I'm going to ask you I'm going to present to you the questions for the next for the next slide.
[2161.0:2166.0] OK so do you guys see the new presentation now.
[2166.0:2195.0] Yes OK thank you OK so the next the next session is going to be it's going to tackle the shared memory framework of let's say talking about distributed algorithms so what we have what we have done currently is if we assume this message passing message passing model.
[2195.0:2224.0] That simply says that you have some processes they only know what is what is there of course state they only have some limited view of the system in a sense that in order to learn a fact about the system and about the state of the complete system they need to receive some message from some from some other process but there is no let's say shared shared memory shared medium between all of these processes.
[2224.0:2253.0] So a process can only learn learn new facts about the system once it receives a message and also it can you know enforce others to learn some new states about the system by sending by sending those messages but now it's shared memory model you have something very similar today but just in the truth there is a there is a memory that can be accessed by all process in the system and now pretty much receiving the message.
[2253.0:2282.0] Is equal to what receiving the message what receiving a message in the message passing model was always simply reading from that memory and what sending a message was is now simply writing to writing to a memory OK so at the class you have seen some algorithms that implement regular regular registers and then implement it.
[2282.0:2310.0] So here we are the first access is concerned with this majority voting algorithm the ABD algorithm that simply assumes that you have a that you have a majority of process being correct so majority of process that cannot crash and you want to implement of course using the so many different ways of using the same process.
[2310.0:2339.0] So maybe I wasn't clear enough so here what we want to do is we want to emulate shared memory on top of message passing so we do not we do not transfer completely to shared memory model not at all actually what we just want to do is implement some of these some of the abstractions that are commonly used in the shared memory system models like registers of course and implement them using the in the in the message passing.
[2339.0:2368.0] Model that we are all familiar with now OK so this majority voting algorithm does implement a regular register with the assumption that there are there are more than half of processes are going to be forever correct that they are not going to crash and here we ask you why every process indeed needs to maintain a copy of the register value in the majority voting algorithm.
[2368.0:2389.0] So we want to pretty much ask you here is why why all processes must take care and must pay attention to what is indeed the value of the register in order for majority voting algorithm to work.
[2389.0:2407.0] OK, access to example to ask you to consider a system with two process and to give an execution a register execution such that each process performs at most operations and the execution is unsafe.
[2407.0:2436.0] What does it mean for an execution to be unsafe so we have a register with the bright operations and read operations these are the only two operations that are possible and an execution is safe if the following calls so if a process invokes a read operation and that read operation is not concurrent with any right operation then that read operation returns the last written value.
[2436.0:2465.96] OK, otherwise if there is a concurrent right operation then read operation can can can return whatever whatever whatever it wants so of course it just needs to the value just needs to needs to belong to some universe of values some domain but otherwise there are no restrictions so execution is safe if you have a read operation that is not concurrent with any right operation and then that read operation returns the last
[2465.96:2494.96] written value otherwise the read operation returns whatever it wants. OK, then we ask you to see similar question but now we want to ask you to provide us with the execution that is safe but not regular so what is now a regular execution so again if read operation is not concurrent with any right operation then the read operation returns the last written value otherwise it returns either the last written value or any value that is concurrent.
[2494.96:2518.96] So I hope that you see the difference between safe and regular executions because if there are concurrent right operations and execution is safe if the read operation returns any value however in this regular execution read must either return the last written value or must return one of the values that is that is concurrently being read.
[2518.96:2546.96] OK, so lastly we ask you to we ask you to just a second we ask you to to give us the execution that is regular but that execution is not atomic but what does that mean? Well that means that
[2546.96:2570.96] if there is not atomic that means that if a read returns a value V and some some subsequent so an execution is atomic if it an execution satisfies the properties of the regular execution and another property that is very important property can be referred to an older
[2570.96:2583.96] or an older that says that if a read returns a value V and a subsequent read returns a value omega then the right of omega does not precede the right of V.
[2583.96:2603.96] OK, so there is a slightly difference there is a difference between regular and atomic atomic registers and atomic registers are stronger primitive and regular registers because of this additional because of this additional property.
[2603.96:2630.96] And lastly we ask you why timestamps that are used in the majority voting are needed there but are not needed in the read one write all algorithm just a small hint read read one write all algorithm that implements regular register uses perfect failure detector.
[2630.96:2650.96] So I guess you can you can you can figure out now what what what might what might give the read one write all algorithm this permission not to use timestamps that are indeed necessary in the majority voting algorithm.
[2650.96:2667.96] OK, so this should be it these are the exercises for the next for the next for the next session so if you don't have any questions we can can wrap this up.
[2667.96:2678.96] So are there any questions.
[2678.96:2690.96] OK, I don't see them. OK guys, so thank you very much for being here today and yes, I guess we'll see you next week.
