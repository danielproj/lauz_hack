~WEEK 3 Lecture: Oct. 3, 2022
~2022-10-03T16:41:56.510+02:00
~https://tube.switch.ch/videos/Tic5ATVAqu
~CS-438 Decentralized Systems Engineering
[0.0:14.94] Okay, welcome back. Let's go ahead and start. So in the last lecture we started looking at decentralized
[14.94:24.5] systems, including especially focusing on the use net as really the first widespread decentralized
[24.5:45.5] system trying to be a public open to all forum for communication. So that anybody could broadcast a message to anyone and discuss things openly on the global network.
[45.5:57.5] And so this week I want to start getting into technical details and see how the how the use net actually actually work.
[57.5:78.5] And more generally how gossip protocols work because use net was at its essence a form of gossip protocol.
[78.5:90.5] Okay, so what's the what's the basic purpose of pretty much any any gossip protocol.
[90.5:107.5] So if you if some of you are taking or have taken the distributed algorithms class this you'll you'll see there's a close connection between gossip and broadcast algorithms.
[107.5:130.5] So so these aren't quite the same but but there's there's a close correspondence. The you know what's the basic idea? Well, you have some kind of network with some potentially arbitrary psychology.
[130.5:142.5] And somebody writes a message on some node say you say you know a use net node. And in the case of use net let's make this concrete.
[142.5:156.5] You know when use when you use net arose like I mentioned these nodes were big nodes like deck Vax digital equipment corporation Vax computers running you units or deck VMS.
[156.5:168.5] And serving a lot of users at a particular campus. So this might be the one the one using that node running on EPFL's.
[168.5:177.5] You know one and only server capable you know capable of renting a use net node.
[177.5:186.5] And then you know so there's a there would be you know each institution.
[186.5:197.5] I would you know probably have have another node and then at each of these institutions there would typically be a lot of users.
[197.5:214.5] Using reading and writing use net messages at that node now this you know this is that important from a theoretical perspective how how this is organized but but from a practical perspective it's useful to understand some of this.
[214.5:221.5] So these were all very much multi user systems now.
[221.5:232.5] So somebody would would write a message like say Alice and one of the user users at EPFL write some message M.
[232.5:248.5] And you know being a use net message there's no destination unlike email on on email that would be a two line saying this is too Bob but use net message is by default just to everyone right.
[248.5:258.5] And the purpose is basically to distribute it to everyone so EPFL's node is going to you know at the at the next time it calls up.
[258.5:261.5] One of its peers.
[261.5:269.5] It's going to try to distribute that copies of that message to the peers right and.
[269.5:282.5] Here's our of any given node or generally a very small subset of the of the whole network right so nobody was connected directly connected to everybody else.
[282.5:297.5] Instead you relied on you know transitive forwarding so the message arrives here at this node and then it gets you know forwarded further to other nodes right.
[297.5:310.5] And this can be an arbitrary topology right so messages you know by default might get trying to get me done the forwarded you know both ways on a link if you know.
[310.5:322.5] If these two nodes you know receive the message about the same time they you know might not know that each other already has it and try to forward it so that's one of the.
[322.5:345.5] Technical issues that we're going to have to deal with but in general you just want to you know have a have a mechanism that you know propagates any given message to all the other nodes in the network and you know ideally it would be nice if that mechanism was robust and you know reliable and.
[345.5:359.5] Tolerated failures in the network and reasonably efficient right so there's there's a lot of considerations in defining such a protocol right.
[359.5:369.5] Okay so let's let's look at so that's the basic goal right.
[369.5:381.5] Just to you know propagate some message and to all nodes right.
[381.5:386.5] So any any questions so far.
[386.5:396.5] So feel free to raise your hand and jump in anytime now let's let's quickly take a look at.
[396.5:418.5] The format of a use net message what what does a use net message concretely contain now I in in the last lecture I gave you a quickly showed you an example of what a message looks like but let's let's let's look at it in a bit more detail right so.
[418.5:428.5] What do you expect so any use net message is formatted basically like an email message right.
[428.5:436.5] This is a long running internet tradition where a text based message starts with a header.
[436.5:456.5] Which is some number of text lines and then a blank line and then an arbitrarily long body which is the rest of the message the rest of the file right this is a very old tradition.
[456.5:470.5] And so so both it's worked well for both email and and use net and other other message formats over the over the decades.
[470.5:481.5] So what do you expect if you're you know if you're trying to design a gossip for broadcast protocol you know what kind of fields would you want in the header.
[481.5:492.5] These are you know of course control things what that that you expect all the nodes to hopefully understand and maybe do something special right the body is just random.
[492.5:501.5] That's just the user's text mostly not uninterpreted is just the content that you want to propagate right so yeah.
[501.5:520.5] Time but good so indeed one of the classic header fields that in both email messages and use net messages is called date which is a date and time right so.
[520.5:533.5] 19 November 78 you know 1353 right you know it can take different forms but there's you know standard.
[533.5:540.5] So standard internet time forms yeah so you want to know approximately when it was sent.
[540.5:556.5] For all sorts of reasons for managing messages and sorting them chronologically as as you net news readers would often do things like that right so yeah good so that's one example what else would we want yeah.
[556.5:585.5] Yeah yeah source source address like who sent it that's a really really good idea to know that so using that message message is have a from field and so as you know the typically looks something like this.
[585.5:603.5] So so the from line is often you know was often basically an email address right so so if you read a message by a Jerry at eagle dot in.
[603.5:613.5] Tom and you wanted to reply privately you could just use that email address to to reply directly in private right yeah.
[613.5:641.5] Yeah great great question you mean how how it found how it would find Jerry that email at eagle dot ATT Comden and how to route to that yeah really good question let's get to that a little bit later because that was a non trivial development in the in the first stages of use net.
[641.5:664.5] You know the early days of use net you would not have been able to use an email address like that because they weren't yet connected with the email system and the way and and the mechanism to look up well how do you get to eagle dot ATT dot common route to it right so that was so so this you know email notation was late use net not not the earliest use net.
[664.5:693.5] So and that's a yeah that's that's important so but there was another field that that this is related to that there was another field that was related to from but different it was called path.
[693.5:707.5] Now what's what's your guess of what path might mean yeah.
[707.5:725.5] How method how the message can be sent to it's very close but kind of exactly the opposite the path is just a record a historical record of the path the message took so far in propagating through the network right so.
[725.5:753.5] So whenever a node first sends out a use net message it uses an almost empty path right so so it would it would start out as something like EPSL bang Alice.
[753.5:771.5] So the the node that's that's sending the message which is on this is node in this case EPSL and the user name at the very after next exclamation point right so.
[771.5:787.5] So this is the message that gets sent out from from EPSL to whatever node X Y so.
[787.5:815.5] Yeah, calling EPSL bang Alice right but suppose node X forwards forwards this message to node Y node X wants to leave a historical record at trail of crumbs just for information purposes well how did this message message arrive at Y right so.
[815.5:831.5] The practice is each each node that a message goes through is going to prepand the string to the path so X is going to modify the path in the message to go to say.
[831.5:858.5] Colin X bang EPSL bang Alice right so in search and text it at the beginning of the path right and so whenever a message arrives you know somewhere else like down at EP or something it's the path is going to be somewhat longer possibly several entries depending on.
[858.5:861.5] You know kind of how how many.
[861.5:873.5] The message went through to to get to a user yeah.
[873.5:901.5] How do you know it's great question yeah so that that's going to be really important because if we don't if we don't figure out like what what messages are the same and what's your what a different we're going to be in trouble as you're seeing already right yeah so yeah how do they know well all you know give you give you the quick answer you know in terms of how use net works.
[901.5:911.5] So use net adds another field called the message ID.
[911.5:930.5] So anytime a host sends a message it's supposed to include a message ID that's a mandatory field and it's supposed to be unique how does it get unique well it could be made unique and you know it can be the content of that.
[930.5:934.5] It can be pretty much any opaque.
[934.5:940.5] The string.
[940.5:957.5] So it can be kind of anything the host chooses but the originating host basically has to promise cross your heart that it's going to be unique and no messages from the same host are ever going to get confused with another message from this host or any other host.
[957.5:972.5] Now in practice well you know how do you how do you do that yeah.
[972.5:990.5] Yeah that's that's kind of a problem if we didn't apply any standard you know to any constraints of what what's in this message ID it sounds like we could easily get conflicts across host you know one host says well I'm going to assign messages sequentially one two three four five.
[990.5:1005.5] The next host does the same well I'm you know also assigning messages one two three four five and we totally can't distinguish you know one host message five from another host message five right.
[1005.5:1032.5] Yeah good great awesome so very advanced you know modern crypto answer crypto age answer we are in the crypto age and you know using hatches and big random number you know cryptographic numbers is a really good way to do that these kinds of things today.
[1032.5:1047.5] So so a very so you know one thing they could do is so just pick a big random number like you know.
[1047.5:1051.5] Like you know 250 six bit.
[1051.5:1054.5] Random number.
[1054.5:1066.5] So they will probabilistically they you know with overwhelming probability will be unique you know as far as we care or it could be say the shop shop to 56.
[1066.5:1081.5] Or a stronger hash algorithm of something bigger and unique right including for a example this host public key will get into into you know kind of those kinds of constructions later in the semester.
[1081.5:1090.5] So you know the first thing that we can be really sure is cryptographically unique I could be that yeah.
[1090.5:1094.5] Okay yeah so great so.
[1094.5:1117.5] You know using that was created long before crypto cryptography was a thing in the you know broader world of digital systems like it was it wasn't even in most it mostly wasn't even invented and even for you know for many years after the invention of say RSA the you know basic public key cryptography.
[1117.5:1127.5] You know it wasn't ever used during corporate into standard standard protocols partly because there was so exotic it was so computationally expensive.
[1127.5:1145.5] You know from the perspective of hardware at the time it would took you know decades to standardize reasonably it was considered a very sensitive thing by the US government so for it was considered classified as a munich did like you know you you send.
[1145.5:1168.5] You know source code containing cryptography across the US border and you could go to jail as an armed smuggler right this was a big thing for a long time people would you know in protest of this anybody ever seen somebody wear a t-shirt with with like a yes or one of the basic cryptography algorithms printed on the t-shirt.
[1168.5:1192.5] So this was a you know this was a way to protest this this long long stand the US government policy and wearing a t-shirt with or like RSA and in pearl in in python or something you can you it in three lines on a t-shirt people would wear those t-shirts across the border in protest to see if anybody would you know pull them over you know just I dare you you border control.
[1192.5:1213.5] You know call me a side and ask me if I'm an armed smuggler because of this python script three line python code yeah so I mean there are all kinds of all kinds of reasons good and really terrible reasons why you know crypto was not a thing you know to be used in normal protocols in.
[1213.5:1224.5] In this in this day so you know nobody would consider you know when when using that will be you know using big random numbers or has to as a public keys or things like that.
[1224.5:1242.5] So yeah instead they just did did something more human read it readable and some and more informal which was they basically develop the convention that usually the message idea is quite opaque instead it has.
[1242.5:1264.5] It would typically have the sequence number assigned by some you know by by the host this would be a host local namespace that you know this host promises never to reuse the sequence number and it doesn't just because it keeps the last sequence number used in a unit file and it's careful about you know updating it after it writes a message right.
[1264.5:1275.5] And then it would typically put an app sign and a unique you know administratively unique enough host name.
[1275.5:1293.5] Right so that might be you know ebfl dot ch or something like that right so so this was just a convention you know nobody really had to promise to do this but you know if you're well behaved you want to make sure your your message ideas are fairly unique well you typically.
[1293.5:1311.5] Did it this way right and they they used you know those those open open closed angle brackets conventionally to to to form these strings right.
[1311.5:1339.5] So of course there not there's no cryptographic guarantee of unique this year no super strong guarantee but this was you know a lot of things in this stage you know happen basically on trust and promises you know okay so you know be good otherwise you know we'll stop talking to you right and most you know most people were most of the developers and administrators of these systems one of the things to work and wanted to cooperate with each other so.
[1339.5:1350.5] This this kind of works mostly okay yeah so so so that's in practice how see what numbers work then.
[1350.5:1367.5] But yeah in in considering this distributor decentralized protocols in general there's there's a variety of options and later on we'll will definitely look in more detail it you know more modern ways to you know identify messages uniquely.
[1367.5:1392.5] Now just to come back to one one well well I'll come come back to that a little bit later just in terms of expanding you know what are what what else do we typically want what else would we want typically in a in a message are we missing something yeah.
[1392.5:1418.5] Size could we could so and and that some message formats have been have been used I think as optional extensions where it does show the size but in classic even that messages just like in classic email messages there's there's actually usually no size field explicitly in the header.
[1418.5:1433.5] Instead it's just it's just implicit like you know a whole message is whatever size it is and you know it's stored in file or or you know you send it in a protocol until the end of the stream or you find a way to
[1433.5:1447.5] to eliminate to in a particular transfer encoding so for particular particular protocol like you use C.P. or N.T.P. the network news protocol you would have you know in that.
[1447.5:1459.5] A protocol you would you would encode say the size of the whole message including header and butter and then send the message so that the other node would know you know when to stop reading the message.
[1459.5:1471.5] But you don't traditionally encode the size in the message itself because well these messages are intended to be human readable and human editable.
[1471.5:1493.5] And if you encoded the size then you would have to very carefully count the number of characters in the body say you know and you know readjust it if you edit the message at all and you know that you know that would be kind of brittle and painful for any you know kind of human you know human in the look right so.
[1493.5:1502.5] So the size is intended to be a femoral and kind of outside the scope of the message itself but yeah that's that's a important.
[1502.5:1506.5] Thanks yeah what else might we want.
[1506.5:1516.5] Ah yes great who who is this message interesting to yeah so there would there would be a news groups.
[1516.5:1524.5] Field there is this is.
[1524.5:1525.5] So.
[1525.5:1534.5] OS dot units for example for you know discussions about you know and there could be multiple news groups as I mentioned in the last night.
[1534.5:1537.5] Yeah so that was very important.
[1537.5:1553.5] There's at least one one other very basic one that that's also common to email yeah subject great so I kind of ran out of space here.
[1553.5:1566.5] What's the message about and of course this is you know free form text.
[1566.5:1576.5] You know if somebody is asking a question about well you know right summarize what what the thing is about is give people a way to.
[1576.5:1589.5] To see whether whether the message might be interesting to them or not yeah so just like email nothing different there.
[1589.5:1613.5] Yeah and then these were really all the basic essentials that are most of these were mandatory like the protocol said well a message is not valid is not complete unless it has at least these fields messages could sometimes have other fields there are a lot of optional fields that were defined that could also be included in some cases.
[1613.5:1619.5] One kind of classic one was called expires.
[1619.5:1623.5] And if you put it there you could put a date.
[1623.5:1641.5] So the intent was well if this message is only relevant until a certain a certain day for example this messages an announcement for an event that's happening in three days well maybe you want to appear being consider it maybe you'll put an expiry date of four days from now so that's.
[1641.5:1644.5] You know and then.
[1644.5:1670.5] If these hosts are are actually paying attention to the expires a date which they didn't always but sometimes did they might basically you know in the four days after the expiry date basically either delete it or or just stop presenting it to the new users anymore to you know if you haven't already read it by the expiry date you're not even going to see it right.
[1670.5:1692.5] So but you know this and very other and some of these other extension fields were you know sometimes sometimes we used and sometimes not you could never reliably you know ensure that like everybody's going to stop seeing a message at some at some particular date or something like that.
[1692.5:1705.5] Okay yeah other questions or comments about these the basic header format yeah.
[1705.5:1732.5] You said verified there feel yes yes so in general yes so each user at each of these know it's just running a typically running a you know news reader writer program similar to an email client you know so a news client basically and in general it's the news client that that feels the feels like you know it gives you a.
[1732.5:1761.5] You feel out just like a new email message you're it's you're going to ask that you enter a subject it's automatically going to fill the date with today's date according to that that note and and so on right yeah so just like sending an email message is mostly going to be manual now that you know that that was on the other hand you know the designers of the using that just like the designers of email very
[1761.5:1781.5] consciously wanted this to be a human readable text based format so that they could be edited you know created or edited manually if needed as well right because well they didn't trust automated systems to always do the right thing or to you know do what you need need to all the time right.
[1781.5:1809.5] And and so there were some circumstances where where people would at least for a while basically right or edit messages you know separately and submit them submit them you know manually to the to the new part of one of the one example of that let me see if I can.
[1809.5:1836.5] So I'm I'm extending the the header down here what one example of that was for a while you know in this in this ultimately failing attempt to control spam on using it you know people really worked hard on this spam problem when it when it when it came with the vengeance in the in the 90s.
[1836.5:1865.5] And one of the mechanisms I think I mentioned last week that they tried to use was to have moderated news groups right where by default the news group would be considered so that so that all of the nodes all of the news net nodes would refuse to you know what wouldn't take just any message from just anyone any user and broadcast it to everyone directly.
[1865.5:1892.5] Instead if a normal user entered the message it would by default become an email message just directed at the well known moderator who's in the the database you know associated with that with that news group just the database of news groups basically would say well this group is moderated by this person and all messages posted to that group first become email messages to that moderator right.
[1892.5:1919.5] And then the moderator had to say okay well this looks like a reasonable message so I'm going to you know initially this was done manually of course they added tools not too long after but initially what you could do if you were the moderator would just pull up the message you know out of your email inbox and type in an additional field called moderator.
[1919.5:1924.5] You're approved.
[1924.5:1953.5] Pull in and your email address whatever and by convention on and then you just post that right and then by conventions both the local node and all the other use net nodes are just going to say ah this this message has a moderator approved fields.
[1953.5:1982.5] They might or might not check that the email address to even matches what what the database says is the correct moderator you know I'm not sure how how pervasively or how carefully they actually check the contents of those moderated moderator approved strings but you know in any case they just look for that field say okay this message was moderator approved we're not going to automatically converted into an email to the moderator is said we're going to post it as an actual gossip message for everybody.
[1982.5:1994.5] To see right so this was the key kind of filter for yeah.
[1994.5:2010.5] Great question the answer is yes these are completely forgeable from it so like I said this is pre cryptography right there was like there were no you know practical cryptographic you know they didn't have digital signatures.
[2010.5:2022.5] So if you're looking at a scheme or you know if they existed they were considered way too exotic difficult costly stuff like that no way we're going to check a digital signature every time we look at a.
[2022.5:2036.5] I use net message or something like that so yeah these were again just a just a trust flag and people could and did like you know if you were tech savvy and you wanted to post spam to a moderated news group.
[2036.5:2048.5] What we had to do was manually prepare you know kind of take a message manually prepare the message add your moderator approved flag to it and send it out.
[2048.5:2056.5] Yeah now yeah.
[2056.5:2085.5] Question yeah so the implications are you know what go away beyond the kind of the forger forgeability of the moderate flag is everything in the header is for forgeable including the front right somebody could could very well you know forge a message saying it's from you you know it's some kind of outrageous message that's going to get everybody everybody's hackles up and get everybody mad at you and so yeah you know I'm basically you know.
[2085.5:2105.5] You know you know harassing you with a with the use net message you know with that looks like it's from you when it's really from me right yeah so well and they knew that this you know could be a problem and it was a problem just come
[2105.5:2134.5] to the degree now and then there were a couple reasons it wasn't all it wasn't as bad of a problem as it might seem like it would be well one was you know I was I was a little bit overly generous and again saying you know how easy it is to forge these namely in general at least as these news reader systems matured anyway again these were all mostly multi-user systems where I reach
[2134.5:2145.5] using that note there's there's a restricted class of administrators you know whoever has root privileges to install and maintain software and there was ordinary users right as
[2145.5:2161.5] soon as these news reader programs were sufficiently mature they would usually not not not let just any ordinary user create a message with the moderator approved or with an arbitrary from feel right so that would that would typically be an administrator
[2161.5:2182.5] privilege like you know you if you're an administrator on a known with privilege yet you can always forge a message that looks anything like you want if you're just an ordinary user you have to talk to the you know news the central news server that's under administrator control on your system and it's going to you know check
[2182.5:2211.5] out if you are you know in the you know from field is valid and you know and if if you really do have moderated privileges on this news group and stuff like that right so so you know unlimited forgery and spamming or something was kind of a privilege of any administrator on any local system right but well as you know like you know how many of you how many of you don't have root privilege on your
[2211.5:2232.5] laptops here you know in front of you right anyone so you know as things transform from a you know multi user you know from multi user you know kind of big you know mini computer and main frame environment to a personal computer you big with
[2232.5:2261.5] personal computers and mobile devices that totally changed and basically everybody became administrators and the this kind of these kind of moderate barriers to forgery became kind of you know when became less and less reliable right so yes so so on the other hand there was at least one other kind of guard to say unlimited forgery say of the from line
[2261.5:2290.5] like how might you know how might I not be able to convincingly forward a message with you know a from line pointing pointing the finger at somebody else anybody see a provision here yeah good the path exactly so the path was basically designed and seen as the main accountability mechanism right if you try to forge a message from
[2290.5:2319.5] somebody at another site you know the path is going to you know and then you send that message out the path is going to obviously lead anybody back to you not back to them right at least assuming as long as you know all the other nodes and along that path aren't also polluting with you right so so if you only have control of your administrative control over your local nodes or even a limited number of nodes around
[2319.5:2341.5] it well you know once the message the message emerges from you know your domain of control it's going to start pointing back to you right and not back to whoever you're trying to point the finger at right so so yeah you know if if you were paying attention you know so so this and this really did
[2341.5:2361.5] off you know moderately often happen somebody would either as a joke or just just to harass somebody for because they are angry or somebody you know for an email from somebody else and you know anyone who is looking carefully could actually see this is obviously can't be from them there's there's some some
[2361.5:2376.5] prankster at work you know and you know and the path would would generally lead to the to the at least to the host where the where the prankster was that and so somebody could call the system administrators say hey you've got somebody at your
[2376.5:2389.5] node forging messages for this person are you going to do anything about it you know that that kind of thing right and again to some degree that worked for a while and you know until it kind of until
[2389.5:2411.5] there were enough nodes on the use net that you know it had basically unaccountable administrators and then it kind of stopped working too but yeah so that was the basic way this is all worked in in those days on the early
[2411.5:2427.5] time yeah good good good good issues so other other questions or or discussion about the basic way using that messages work now we'll come back to some of the
[2427.5:2437.5] technicalities some further technicalities here that are embedded in here but this is a good start of point.
[2437.5:2463.5] Okay so if not actually this is that this is probably good time to take to take a short break because we're we're going to switch to much more say slightly more theoretical aspect and of how this how this routing and gossip and propagation works so let's come back at 11.0
[2463.5:2479.5] 11.0.6. Okay 10 minute break. Okay so I will see you soon.
[2479.5:2507.5] Okay let's continue. Okay so we've been we've been going through some of the very pragmatic elements of how how using that messages work let's let's look a little bit deeper into some of the some of the theory behind how efficient how gossip works and how to make it efficient.
[2507.5:2521.5] But also we'll we'll look at efficiency issues as well as correctness.
[2521.5:2539.5] So we actually let's again look at a example topology and I'll just name the nodes informally.
[2539.5:2568.5] Let's let's talk you know more more precisely and concretely about like you know what is a gossip algorithm what what fundamentally do these nodes need to do when they get a new message either from a local user or a message has been propagated from some user somewhere else right what what is what does the what should they basic gossip algorithm do right so
[2568.5:2594.5] for example you know Alice at a sends a message and a wants to propagate it to other nodes let's say B receives message M and is trying to decide what to do right so
[2594.5:2609.5] what's the most basic say naive algorithm you can you can come up with not even worrying too much about correctness like what what's the simplest possible thing we might try to do yes
[2609.5:2637.5] send it to all of the say peer the immediate peers yeah so let's say like on receiving a message and right sends in to all peers great so what's the problem with that why aren't we done
[2637.5:2655.5] so I was like a perfectly good algorithm gossip algorithm to me yeah oops yeah exactly so you might indeed receive the same message twice like say you know B sees the message and whoops
[2655.5:2669.5] forward to see that see is you know because this is an arbitrary topology there can be cycles in it right so if this was a tree topology you know guaranteed no cycles if you know if you
[2669.5:2685.5] know you know we're not you're theory if it was a tree topology with no cycles then this algorithm actually would would work right but on you know a general network with cycles while there's definitely won't work because well see is going to receive two
[2685.5:2697.5] copies of message M and so what's what's he going to do under this basic algorithm yeah you're solving it yeah but let's let's
[2697.5:2707.5] probe the the badness of this problem before we tell it yeah so but you're you're right about the solution yeah one of them yeah
[2707.5:2729.5] good that's another good solution that's often used on on Ethernet so take the take the network that's not a tree and force it to be a tree for purposes of the distributed
[2729.5:2742.5] message messaging that's exactly what we call the spanning free protocol or SCP on Ethernet systems so yeah you know there but what are what problem do we need to solve for
[2742.5:2763.5] precisely before we before we get to get to that like what what's really bad thing happens with this basic algorithm yeah exactly so you know C is going to get two copies of
[2763.5:2775.5] M and you know for both of those copies of M it's going to send another copy of M out to all its peers right and they're going to keep going around in in a loop both
[2775.5:2787.5] fractions but it's actually a lot worse than that it's not just it's it's not merely you know infinite you know messages but it's a it's a literal exponential explosion of
[2787.5:2811.5] infinite messages right why is that yeah so again the solution yeah good good yeah so that's that's definitely so the message idea is critical and actually solving this at least in the case of use net
[2811.5:2835.5] but you know I just want to push a little bit farther on the problem right you know why is it you know is it nearly that you know a copy or two of messages are going to be going around those loops forever yeah exactly exactly so there's an
[2835.5:2859.5] exponential explosion like every time a message arise say back at any node with more than two neighbors that that node is going to receive one message and send out two or more that will continue that will continue you know exploding in number right each each new time around yeah
[2859.5:2887.5] exactly yeah yeah so I so good point so we could make this algorithm a little bit less naive by extending it as to all peers except the sender except the the peer that we received it from that would at least address the you know kind of the end of the line
[2887.5:2907.5] problem like a message with you know would reach a host with you know with no with with only one neighbor and it would stop there and you know wouldn't get sent back but you know that wouldn't solve the general cycle problem so so you know that optimization you know doesn't doesn't help us very much we need
[2907.5:2924.5] something fundamentally more powerful to avoid this exponential you know blow up issue and so I you know I'm emphasizing this partly because you you have to be aware that like in using it in the history of using that and many other networking systems
[2924.5:2936.5] precisely those kinds of exponential explosions have happened all the time because you know really often because of some stupid bugs somewhere right you know so very very minor minor bugs in a
[2936.5:2953.5] gossip system can accidentally lead to exactly that happening and total network melt that meltdown basically right so so you know I it's just a really easy mistake to make you know if if you are
[2953.5:2974.5] even aware of the solution you're trying to implement the solution but you implement the solutions slightly wrong you get exactly this and a network meltdown because of the exponential explosion right okay so how do we actually solve this let's yes so so let's come back to this to classic solutions
[2974.5:3001.5] okay yeah so
[3001.5:3029.5] so there are really two classic solutions you know approaches that have been used in this in this path you know historically
[3029.5:3045.5] and you you brought up both of it right so the first solution is recognize somehow recognize
[3045.5:3063.5] messages received already right so somehow record keep keep a keep a database a record of which messages I have received already
[3063.5:3082.5] and don't re broadcast them right if I if I receive multiple a second copy of the same message from different sources somehow figure that out and don't you know don't re broadcast that automatically right and the second the second general solution was what you
[3082.5:3108.5] suggested which is somehow by forcefully if necessary restrict the graph to a tree with no cycles right ethernet STP or spending tree
[3108.5:3125.5] protocol is the classic example so yeah you will when it's a good good question yeah so here there's there's subtleties in let's let's focus on solution one now just
[3125.5:3135.5] to quickly say solution to is is also very technically interesting kind of how to make something like spanning pre-proticle work there's a lot of interesting stuff in there I wasn't I'm not
[3135.5:3149.5] planning to dive into deal detail with that I just a general note these you know spanning tree protocol has historically proven to be super brittle right like like you know the slightest thing goes wrong as e
[3149.5:3159.5] femoral network miss miss immigration or or or you know things like that and you can suddenly find yourself back into explosions this is something that has killed
[3159.5:3167.5] many many times very frequently over the last decades like just something going wrong with spanning tree protocol boom no more no more e
[3167.5:3179.5] pfl network for you know until the administrators race to figure out what the problem is right so I would say just you know just judging history you know
[3179.5:3189.5] historically purely I would recommend not going down route to ever you know in the design of new system right if you're dealing with an ethernet and you have to use
[3189.5:3199.5] spanning tree protocol yeah go ahead you know it's interesting fun if you go if you have any choices in the future stay away from choice to go to choice one right so
[3199.5:3211.5] okay now let's focus on choice one right how do we recognize messages received all right so we have you know there's two potential ways to obvious ways to do that in the case of
[3211.5:3221.5] use net messages we could look at the message ID we could look at the path right there might be other choices actually I can think of a
[3221.5:3235.5] third choice already that would be say say a more modern crypto we choice anyone can anyone guess what I might have in mind you know if we
[3235.5:3245.5] if we do have you know modern cryptography check a signature except this signature is not guaranteed to be a you know kind of unique per
[3245.5:3253.5] stage yet okay well you could do that that's even more advanced you know you know you know crypto block chain E as opposed to crypto
[3253.5:3263.5] cryptography but yeah yeah you could do that but you know even simpler yeah yeah a has to say cryptographic has to
[3263.5:3271.5] the message it's you know you're guaranteed to be cryptographically unique if the message changes the hash will change if the
[3271.5:3283.5] hasn't changed the hash doesn't change right so all of these all of these approaches might be might be attractive ways to to distinguish whether whether
[3283.5:3291.5] I've seen a message before or not unfortunately like you know how they actually work you know or don't work in practice can be
[3291.5:3301.5] complicated right so well what what using it actually does we'll just I'll just say well it uses the message ID right that's the that's the
[3301.5:3309.5] standard user net approach you you know you receive a message so
[3309.5:3323.5] so you use the message ID to uniquely identify the message you receive a message you look up in a database of the you know
[3323.5:3330.5] messages you receive over the past few weeks or month or two or year or something like that you say well have
[3330.5:3346.5] it do I already have that message ID in the database yes I've already seen the message don't re-broadcast it no I'm going to treat it as new right so yeah so that has to that has some implications yeah
[3346.5:3362.5] yeah so I I'm going to call that pretty similar to the suggestion of using the path right so so we've got this path field
[3362.5:3378.5] that I you know that I that I mentioned to you which seems quite promising it it tells you exactly which node the message has gone through on the way to you
[3378.5:3388.5] wherever you happen to be in the network right so you know coming back to whoops to this diagram right if a message comes from
[3388.5:3407.5] eight to B to C then the message is going to arrive here with a path B bang a bang maybe Alice if Alice is the user user at node a right and then if C
[3407.5:3429.5] forwards it then she is going to add C bang to the beginning of that now there is kind of a so yeah so this might kind of work but there is also kind of a problem yeah
[3437.5:3451.5] yeah good good point so this is this is one of the key downsides of this you know this this idea of just recognizing messages we've already seen before
[3451.5:3463.5] well our nodes are definitely not stateless anymore they have to have state they have to store you know as better method IDs or you know if we're recognizing path you know using the path
[3463.5:3473.5] they've got to recognize paths we've seen before or path elements that we've seen before or we could have say hashes of the message and we've got a
[3473.5:3481.5] recorded database of you know which message has has and you might have seen before right in any of these solutions
[3481.5:3495.5] and so that's that's going to be a cost and in practice we've got to think about that right especially if the system is supposed to be long running it's going to go on for decades should we be expected to store you know the
[3495.5:3505.5] message IDs we've all we've ever seen over the past you know decades of using that's operation do you think using that nodes do that
[3505.5:3529.5] yeah good yeah great great suggested yeah so as long as if you can calculate or you know estimate or just give a very rough you know conservative
[3529.5:3541.5] upper bound on what's the longest propagation time any message who there's who would ever take to to propagate across the whole network you know and then you take that time and double it or
[3541.5:3557.5] multiplied by 10 to be really conservative or something and say okay I expect you know no messages ever going to take you know longer than this to propagate around the network and so you know if I calculate that time I just keep that that much history
[3557.5:3577.5] in you know past message IDs if if I calculate that that's you know a week or a month or something I keep only the last week or last last months worth of message IDs right so that can totally work now it doesn't always work perfectly like what what
[3577.5:3605.5] would go wrong with that approach the ideas and things have gone wrong believe me yeah yeah so so that's the that's the general problem with the message idea approach right yeah so so if if somebody either
[3605.5:3630.5] knows by accident or even maliciously you know picks the same message ID as some some other message that's already propagating in the system then you know nodes that see this you know nodes will will not be able to distinguish the two right and this can be a denial of service attack actually right if you're really quick and you see a message come from
[3630.5:3650.5] you know someone you don't like right you see a you you you're closely connected to Alice Alice's machine a and you see oh Alice posted a message you know I don't like Alice I want to prevent anybody I want to censor Alice well what you what you do you quickly as quickly as possible you post your own
[3650.5:3665.5] message you know about anything you know random spam or whatever but reusing Alice's message ID from the message you just saw from Alice right and if you successfully get your you know message with that
[3665.5:3694.5] message ID out you know and more widely spread than you know the analysis messages all the other use net nodes are going to see your message and they're going to reject Alice's message because well I've already seen this message it's from you know it's your message and this you know who's this Alice spammer who's trying to you know trying to duplicate your messages right so yeah so that's that can be a problem this is another you know kind of
[3694.5:3714.5] vulnerability to forgery denial of service basically or censorship through for through message ID forgery that you net have I don't remember this very commonly being a practical problem in using history but I'm sure it's happened a few times in some way right
[3714.5:3732.5] yeah but yeah but but coming back to the issue of just like you know kind of setting a time limit on on how long we keep old message IDs well what if the time limit we choose is too short
[3732.5:3752.5] like there actually is unbeknownst to us of a path through the network like even just you know some pair of nodes that talks to each other really rarely and you know just you know just these two nodes are kind of solely responsible for kind of a accident perhaps accidental time warp where you know a bunch of messages gets
[3752.5:3770.5] huge up on this node and then just sits there for a month you know and then you know a month later their connection is finally restored and you know the big back to messages propagates to the other new and the other news they all a bunch of new messages right okay I'm going to spread
[3770.5:3781.5] them to everyone you know without realizing that they're you know a month old and everybody else has forgotten the message IDs right so this whole new batch the messages explode through the network again right
[3781.5:3802.5] now again this is a problem that you know I don't think as far as I know has not been a big problem in practice in use net history partly just because they you know they pick these experee days very conservatively just you know keep the message IDs way longer than you think you know any
[3802.5:3813.5] message propagation time you know should reasonably take right but well you know there's always consequences if you're wrong so this is just you know a general thing you always have to think about in a
[3813.5:3830.5] decentralized system every rule that you come up with will be broken sometime by somebody somewhere and how bad is it you know when it does get broken right and so if you can if you can have a sudden explosion in duplicate messages you know
[3830.5:3850.5] it well if it's only a one-time thing maybe not too bad if it's if it can be you know something that repeats itself over and over and over or explodes further that can be worse right so so you have to think about that yeah good so but you know we're we're on the on the road to to reasonable
[3850.5:3860.5] reasonable solutions now let's come back to this example of just using the path so that can work depending on how you do it but there's an important
[3860.5:3876.5] limitation right if if you use a messages path to determine you know kind of who you shouldn't forward it to like so so I I'm assuming the intended algorithm is basically well look on the
[3876.5:3890.5] path that I see in the the arriving message and don't forward it to any peers that are already on that path right yeah so so that will like if you do that that will indeed
[3890.5:3904.5] solve kind of the worst of the problem it'll it'll stop the infinite explosion you know of messages especially the exponential explosion right so but it well it also won't be very
[3904.5:3926.5] efficient can you can you see why yeah
[3926.5:3943.5] yeah well it yeah I think I get what you so so using the so the path only shows which nodes were immediately on the line on a
[3943.5:3953.5] particular path that the message took from its origin to you it doesn't give you any information about what other paths what other of the many
[3953.5:3969.5] potentially exponential number of other paths the message also took in the meantime right so if you're only using what the path tells you then you know in any densely connected network you're
[3969.5:3981.5] probably often going to get the same message from several different paths you know approximately concurrently and you know each of those paths is going to be you
[3981.5:3993.5] know several several other nodes that aren't on any of those paths you know that are in your peers and aren't yet on the path that you that you've got that
[3993.5:4004.5] message from but they're never never the less fairly likely to have gotten the message from some other VSM other path right and you're going to be sending duplicate copies to all of those
[4004.5:4019.5] neighbors that you know weren't on the immediate path the one immediate path you were looking at that right so so basically so so you know basically it can
[4019.5:4037.5] can work but it's not very efficient now and we'll come back to this efficiency issue in a minute but at least you know if we've solved the exponential
[4037.5:4052.5] explosion and network meltdown problem where we're on the right path so to speak right but okay so what about this path ID so this is this is I think an intriguing example of where it
[4052.5:4063.5] could work or it could you know it could be buggy or you could do it wrong and it could disasterously not work do you you see what I mean like you know so
[4063.5:4076.5] so suppose you take a shot 256 of the whole message of a whole using that message and treat that as you know the message ID you you use that as as the you know kind of
[4076.5:4091.5] unique string to decide whether you've seen the message before or not were you raising your handball okay yeah anyone can you see something that might go wrong here with just like this simple use of
[4091.5:4108.5] cryptographic cash yeah oops yeah yeah okay yeah so we just did this naively we passed the whole message including that pass we'd be in big trouble
[4108.5:4117.5] immediately right oops every single node that the message propagates to is going to add to the path that changes the message it's a new
[4117.5:4129.5] message now as far as the cryptographic algorithm is concerned right every single hop is going to make it you know a new message by from the perspective of that that scheme and we're
[4129.5:4138.5] going to be back to massive you know complete network meltdown territory right because it's going to be an excellent exponential of explosions of quote unquote new messages that
[4138.5:4154.5] differ only in the path right of course yeah this can be fixed like exactly as you suggested you can you can do things like well okay the path should not be included in the hash right now well and there might be some
[4154.5:4165.5] other fields that you won't don't want to include in the hatch now if you look at so the use net and email standards there is actually especially for things like a signed
[4165.5:4177.5] message is things like that you you do have to distinguish you have to categorize all the header fields all the standard header fields into two categories one that you know one
[4177.5:4188.5] category that you know intermediate nodes can and are often expected to modify in transit like the path and the other one the other one for fields that
[4188.5:4202.5] are not supposed to modify typically subject for example right so if you're signing an email message or or or a use net message you would like the signature to protect the subject
[4202.5:4210.5] line so that somebody can you know kind of forge a different subject line than the one you said on the other hand it had better not cover the the path
[4210.5:4224.5] line because that has to be modified all the way through right so you you so you can totally do that you know divide the header lines into these two categories carefully make sure the hash covers the ones that you know are not supposed to
[4224.5:4234.5] change and doesn't cover the ones that that are supposed that are supposed to change that can work and you have to do that kind of things you know when you incorporate
[4234.5:4248.5] that in the geography in other ways like like you know sign messages but that's the that's in general that's the big problem right
[4248.5:4267.5] yeah and for for that reason among others you know using that always basically you know stuck with this tradition of just say okay message ID you know everybody
[4267.5:4284.5] promised to be good choose your own unique message IDs you know be good and don't forge somebody else's message IDs if the DOS them you know so on and you know largely that that worked even if it was never perfect
[4284.5:4301.5] okay so yeah
[4301.5:4313.5] yeah you mean the the the computational cost of has to yes absolutely so that what you know that when you know using that was first first created you know cryptographic
[4313.5:4324.5] hash algorithms were not even really a thing much or at least it you know not beyond you know very tight you know cryptography you know cryptography geek circles right
[4324.5:4336.5] and even when they did become you know more standardized and available they were not considered you know computationally efficient enough you want me to compute you know one of these expensive
[4336.5:4350.5] hastings on every single bite of every single message that comes through through my using that node forget it go away where you know what rock did you come from right you know so those were very different times in terms of the power of you know
[4350.5:4367.5] processors and you know kind of what was seen as practical and not practical in terms of cryptography that's totally changed now you know these days yeah computer has for all across the whole message no problem at all it's practically standard yeah
[4367.5:4390.5] so you know something I completely admitted from this from this header was anything like a two lie right and so in an email message you would always expect an email
[4390.5:4405.5] message to have a two line saying that who the destination is right using that message is traditionally never had a two line because the you know you know you know just trying to be a
[4405.5:4425.5] gossip or broadcast protocol is trying to basically broad the destination is always implicitly well the logical news group right this abstraction of a of a news group which can be everywhere right so so to achieve that abstraction the idea was well you know by default
[4425.5:4446.5] you broadcast the message across all the nodes and each node just presents to it's to its users well you know if you're trying to read this particular news group here the messages in this news group right now that of course creates a big storage efficiency question right can everybody afford to store all the copies of all the
[4446.5:4463.5] messages for every one across the whole network right is that partly what you're getting to and and use net philosophy was let's say the answer is yes don't be on use net unless you're willing to buy a big disc or several big
[4463.5:4481.5] messages that's to store all these messages you know for you know it was kind of a community service kind of spirit right now it that wasn't you know that that didn't always go you know infinitely like you know this was costly sometimes and some
[4481.5:4504.5] use net sites would say okay we're going to carry you know all of the you know most of the news sites but but there's these particular news groups where people are sending big binary files like binary images videos software distributions those are taking
[4504.5:4520.5] absolutely enormous you know gigabyte it's worth a space we're going to drop those news groups so we're just not going to accept or retransmit or store any messages from those news groups sorry you know we can't don't want to it's not in our priorities and that was always the
[4520.5:4539.5] prerogative of the administrator of a of a of a use net site but you know for mostly like for for for most messages not you know not the news groups that were commonly used for for these big you know binary things you know usually
[4539.5:4556.5] the messages tended to be small they're just text you know and and so in practice you know storage you know basically the equivalent of more more is law for storage kept making storage so you know infinitely cheaper is exponentially cheaper you know over the next
[4556.5:4568.5] site cycle yeah you're using it you know storage capacity runs low just go bit by a bigger disk using you don't have to do that all all that often and you know it it would kind of kind of keep up right yeah
[4568.5:4594.5] yeah yeah good question so and this again changed what was kind of a local administrative policy issue that the varied from one from one use net site to another so some
[4594.5:4610.5] use net site administrators would be digital pack rats like I want to keep all of my messages forever I'm never going to expire anything from my server because I want to complete use net archive all going all the way back from you know 1979 right so and I'm
[4610.5:4620.5] willing to invest in the storage you know bigger disks more disks and stuff like that to do that right some sites would do that Google you know it's at some point very deliberately and very
[4620.5:4635.5] publicly said okay we are creating a use net archive is going to be publicly available it's going to contain every every use net post ever that we you know that we're aware of right so you know some sites would do that but many
[4635.5:4647.5] others would say okay you know to control things we're just going to keep you know keep all messages for the past three months you know and well if something hasn't
[4647.5:4661.5] propagated through us in three months or you know sorry it's lost right or you know if some neighbor site wants to catch up they're only going to get the last three months you know worth the messages and you know they're not
[4661.5:4676.5] going to get the rest of history from me right yeah well let me get to the protocol
[4676.5:4693.5] actually I need to get to the protocol otherwise I won't have time in fact the so the basic so what one of the basic
[4693.5:4714.5] optimizations of this protocol I you know I mentioned there can be efficiency issues so one was what what
[4714.5:4727.5] what use net what use net into implemented in what they call the network news transfer protocol that's that's the they peer to peer that's the more recent peer to peer
[4727.5:4742.5] protocol that using that news nodes use the transfer messages to each other basically they wouldn't follow this you know this naive algorithm even even
[4742.5:4756.5] the one and have to to check message IDs to make sure I you know I haven't seen the message before what they would do is a no you know as soon as a peer goes online one
[4756.5:4768.5] would say one would send to the other node let's say we have two nodes Alice and Bob or a and B a calls up B you know in or decides to
[4768.5:4789.5] intermit intermittently gossip with B so a sends a message called I have right so a sense to be a message that basically looks like this I have
[4789.5:4814.5] message ID one message ID two and so on a big list of message IDs right so that's my I have message so I have I'm just telling you you know
[4814.5:4836.5] I have recently received you know in case it's of interest to you messages whose message IDs are you know on this on this list right now how does and then B looks up in its local database right well
[4836.5:4853.5] okay which of these message IDs that are being offered have I not already seen before so B is going to pick a subset of this message of these message IDs just the subset that B hasn't already seen and B is going to send a message a response call
[4853.5:4872.5] send me so and that's also going to have a list of message IDs like maybe maybe B has seen message ID one already so it's going to cross that office list but it hasn't seen message ID two so it's going to ask for that right
[4872.5:4894.5] and so and so on for some subset of the list that a of the message IDs that a offer okay now yeah so so this is you know what what's called a classic I have send me
[4894.5:4923.5] so it's kind of obvious and it and it can in practice increase the efficiency a lot in especially in terms of protocols like like using that now what you know what what does it improve and what doesn't it improve do you see like you know kind of the precise useful efficiency property that this provides
[4923.5:4950.5] yeah yeah so you know if if B has already received the content of the message from any other node it's never going to receive the content of the same message twice because yeah it's you know it's going to you know after the
[4950.5:4968.5] first time it's going to say okay I already have that and it's going to only send send me lists that don't include that message right and in a protocol like using that where the content of the messages typically quite a bit bigger than the message ID right your message ID is just this little thing content of the message might be big might be huge so that's
[4968.5:4980.5] a lot of bandit for sure right so very very pragmatic now does it save on message ID transmission well but go ahead you wanted to ask
[4980.5:5001.5] yeah good question yeah how does A decide which message ID is to offer yeah we we kind of glossed over that that's that's an important point yeah so now in practice if any always sense you know if A is one of these
[5001.5:5018.5] digital pack rats that you know kind of archived messages forever and every time it starts up the protocol it's going to offer every single message ID it has in its archive back from 1979 then even just the list of message IDs is going to be absolutely
[5018.5:5032.5] enormous right so you can kind of guess that you know use that was not designed that way right you you wouldn't normally want to do that right so you've got to limit the even just the size of the list of message IDs you
[5032.5:5050.5] send somehow right so let's see what's your you have a suggestion how how you might limit that list yeah exactly so you consider this you consider that part of the peer to
[5050.5:5064.5] peer state right you know we assume that a knows B be know a these that this is a you know direct you know peer to peer relationship is probably not too much to ask for a to remember a little bit of state about
[5064.5:5077.5] B and vice versa right they kind of have to anyway just to know that the other exists right and so let's add to that state well what's the what's the last message ID in my database the most
[5077.5:5092.5] recent message ID in my database you know where everything before that I've already offered to to to be right so a you know if a just keeps a keeps a it's list of message IDs in chronic
[5092.5:5103.5] chronological order you know of you know the sequence that a received the message messages for example and you know for each of its peers like B I just keep a
[5103.5:5115.5] border pointer into that chronological order okay I have already offered to be everything you know all message IDs up to this point then you know next time I talk to be okay you know I'm going to offer
[5115.5:5127.5] everything from that point up to the you know the end of the list as of as of that moment okay you want any of these yes no here you know move the move the the peer to peer state
[5127.5:5142.5] forward okay yeah so that's that's the basic you know kind of standards you know a state full approach that generally works fine now it can have it can have consequences like you know if if
[5142.5:5151.5] he is actually a brand new node just coming on the network and a is actually a digital pack rat node that does in fact have all the
[5151.5:5172.5] message IDs you know from 1979 then you know he doesn't have any state for be yet and you know should a literally offer all of the message IDs since 1979 or should it offer them in batches or should it only offer you know messages back to a configurable you know
[5172.5:5191.5] that's the reason like the last years worth of messages at most or something this is these were issues that you know of course affect practical operation and you know that we're up to ultimately up to the administrators of different systems and you know details very right
[5191.5:5216.5] important important practical issues okay so yeah yeah any yeah but but you know at least at least getting to where we we can ensure that we only send the content of the message once to each to each know that's that's a very important practical
[5216.5:5230.5] advantage now there are disadvantages of this right we still have it like if you if you do an asymptotic you know theoretical analysis you're still not going to achieve you know say an as a
[5230.5:5249.5] methodically operative optimal distribution efficiency because of all of these message IDs at least all the message IDs are still going to get cast you know very redundantly to a bunch of the notes you know as you know they're going to get you know multiple copies at least of
[5249.5:5267.5] message IDs as part of this protocol when you know in principle it would be kind of nice if we could you know guarantee that each each note only received one copy of you know anything her per message right so you know that that's
[5267.5:5276.5] that's a limitation that well the you know maintainers of use network never that concerned about but it is a you know interesting concern in theory
[5276.5:5301.5] and we'll and next time we'll look at gossip protocols that can can solve that and then well in principle and then oh yeah the other the other issue with this kind of
[5301.5:5315.5] critical is there's this round trip I have send me particle requires an interactive exchange you know a has to ask the well which of these messages do you want be has to
[5315.5:5328.5] respond and only then can a actually send those messages right so if if the latency between a and B is pretty big like you know a and B are big satellite links then this additional
[5328.5:5344.5] round trip actually you know cost some time right it might be faster if you want really fast propagation then maybe a flavor of the naive algorithm would be better like I just you know if I don't already know that you already have the
[5344.5:5357.5] message let me just send you a copy in case you don't have it knowing full well that it's you know there's a good chance it's a duplicate but you wanted everything as fast as quickly as you can so maybe you will pay the bandwidth right so that's
[5357.5:5375.5] another choice you know that you can make them in some cases and it's a case of we often have to make choices between latency you know the best possible latency and you know more bandwidth efficiency and that's that's one example
[5375.5:5390.5] right and so yes so so there's no there's definitely no you know single optimal best gossip algorithm this is a you know kind of a launching point for for a lot of
[5390.5:5404.5] interesting protocols that that achieve this gossip or broadcast goal in different ways yeah so so if I was if I was operating on time I would have already gotten into
[5404.5:5423.5] a few read up some of the theoretical and the entropy and rumor mongering protocols but I won't have time today so I'll catch up on that next next lecture next week okay okay yeah in the meantime I have have a great
[5423.5:5434.5] and see you see next week
